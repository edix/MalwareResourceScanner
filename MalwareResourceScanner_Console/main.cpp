#include <tchar.h>
#include <Windows.h>
#include <iostream>
#include "PeFile.h"

void ShowLastError()
{
	DWORD dwLastError;
	LPWSTR szMsgBuffer = NULL;

	dwLastError = GetLastError();

	FormatMessageW(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        szMsgBuffer,
        0, NULL 
		);

	printf( "ERROR: %08x ( %08d )\nMESSAGE: %S\n", dwLastError, dwLastError, szMsgBuffer );
}

void ShowInfo()
{
	printf( "Usage:\n" );
	printf( "mrs.exe <optional parameters> <filepath>\n");
	printf( "      -d <path>                  Scans directory\n");
	printf( "      -unpack                    Auto unpack found files\n" );
	printf( "      -quickscan                 Quick-Scan Windows start up programs\n" );
	printf( "      -v                         Try to unpack also non-PE files\n" );
	printf( "\n\n" );
}

BOOL DumpBufferToFile( LPWSTR szName, BYTE* lpBuffer, DWORD dwSize )
{
	HANDLE hFile;
	DWORD dwNumberOfBytesWritten = 0;
	BOOL fResult = FALSE;

	hFile = CreateFileW( szName, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
	if ( hFile != INVALID_HANDLE_VALUE )
	{
		if ( WriteFile( hFile, lpBuffer, dwSize, &dwNumberOfBytesWritten, NULL ) && dwNumberOfBytesWritten == dwSize )
		{
			fResult = TRUE;
		}
		CloseHandle( hFile );
	}
	return fResult;
}

DWORD WINAPI MyResourcesCallback ( LPVOID lpObject, DWORD dwMessage, LPVOID lpEntry, LPVOID lpParam1 )
{
	CPeFile *pFile = (CPeFile*)lpObject;
	//ResourceDirectoryEntry *pEntry = (ResourceDirectoryEntry*)lpEntry;
	XRayInformation *lpInformation = NULL;
	BYTE* pAddress = NULL;
	WCHAR szName[ MAX_PATH ] = { 0 };

	switch ( dwMessage )
	{
		case RM_XRAY:
			//
			// Message 3 is that we have found a PE file in the resource directory.
			//
			lpInformation = (XRayInformation*)lpParam1;

			pAddress = (BYTE*)(pFile->GetBuffer() + lpInformation->dwFileOffset);

			printf( "    Type: 0x%08x, Name: 0x%08x, Language: 0x%08x, "
					"Offset: 0x%08llx, Size: 0x%08x\n    Encryption Key: 0x%08llx\n\n",
				lpInformation->lpType ? lpInformation->lpType->nIntegerID : 0, 
				lpInformation->lpName ? lpInformation->lpName->nIntegerID : 0, 
				lpInformation->lpLanguage ? lpInformation->lpLanguage->nIntegerID : 0,
				lpInformation->dwFileOffset, 
				lpInformation->lpDataEntry ? lpInformation->lpDataEntry->dwSize : 0, 
				lpInformation->ui64EncryptionKey);

			// 
			// dump file
			//
			if ( pFile->GetUnpackFlag() )
			{
				swprintf_s( szName, MAX_PATH, L"%s_%d.bin", pFile->GetFileName(), pFile->GetDumpIndex() );

				if ( !DumpBufferToFile( szName, pAddress, lpInformation->lpDataEntry->dwSize ) )
				{
					printf( "    Can't dump to file! (Last Error : %08d d)\n\n", GetLastError() );
				}
				else
				{
					printf( "    Dumped to: %S\n\n", szName );
					pFile->IncDumpIndex();
				}
			}
			break;
	}
	return 0;
}


BOOL ScanFile( CPeFile &pFile, LPWSTR lpszFileName, BOOL fVerbose )
{
	BOOL fResult = FALSE;
	if ( pFile.LoadFile(lpszFileName) )
	{
		printf( "%S\n", lpszFileName );
		fResult = pFile.ParseResources();
	}
	else if ( fVerbose )
	{
		UINT64 ui64Key = 0;
		pFile.LoadFile(lpszFileName);
		fResult = pFile.XRayBuffer( pFile.GetBuffer(), pFile.GetSize(), ui64Key );
		if ( fResult ) 
		{
			XRayInformation info = { 0 };
			ResourceDataEntry entry = { 0 };
			info.ui64EncryptionKey = ui64Key;
			entry.dwSize = pFile.GetSize();
			info.lpDataEntry = &entry;
			printf( "%S\n", lpszFileName );
			MyResourcesCallback( (LPVOID)&pFile, RM_XRAY, NULL, (LPVOID)&info );
		}
	}

	return fResult;
}

BOOL ScanDirectory( CPeFile &pFile, LPWSTR lpszDirectory, BOOL fVerbose )
{
	WCHAR szSearchFilter[ MAX_PATH + 1];
	WCHAR szFullPath[ MAX_PATH + 1];
	WIN32_FIND_DATAW fdFileData = { 0 };
	HANDLE hSearch;
	BOOL fResult = FALSE;

	wcsncpy_s( szSearchFilter, MAX_PATH, lpszDirectory, MAX_PATH );
	wcscat_s( szSearchFilter, MAX_PATH - wcslen(szSearchFilter), L"\\*.*" );

	hSearch = FindFirstFileW( szSearchFilter, &fdFileData );

	if ( hSearch != INVALID_HANDLE_VALUE )
	{
		do
		{
			if ( wcscmp( fdFileData.cFileName, L"." ) == 0 || wcscmp( fdFileData.cFileName, L".." ) == 0 )
				continue;

			wcsncpy_s( szFullPath, MAX_PATH, lpszDirectory, MAX_PATH );
			wcscat_s( szFullPath, MAX_PATH - wcslen(szFullPath), fdFileData.cFileName );

			ScanFile( pFile, szFullPath, fVerbose );
		} while ( FindNextFileW( hSearch, &fdFileData ) );
	}

	return fResult;
}

BOOL FileExists( LPWSTR lpszFileName )
{
	HANDLE hFile;

	hFile = CreateFileW( lpszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
	if ( hFile != INVALID_HANDLE_VALUE )
	{
		CloseHandle( hFile );
		return TRUE;
	}
	return FALSE;
}


LPWSTR ExtractFileName( LPCWSTR lpszSrc, DWORD dwSize, LPWSTR lpszDestinationPath )
{
	BOOL fResult = FALSE;
	WCHAR *szPos = NULL;
	WCHAR *szSpace = NULL;
	LPWSTR lpszDestination;

	lpszDestination = lpszDestinationPath;

	if ( !lpszSrc || !lpszDestination ) 
		return NULL;

	wcsncpy_s( lpszDestination, dwSize, lpszSrc, dwSize );

	//
	// If first character is a " we will ignore it
	//
	if ( *lpszDestination == '"' )
	{
		lpszDestination += 1;
		szPos = wcschr( lpszDestination, '"' );
		if ( szPos ) 
		{
			*szPos = '\0';
		}
	}
	//
	// Check if path starts with rundll32
	//
	if ( _wcsnicmp( lpszDestination, L"rundll32", 8 ) == 0 )
	{
		szPos = wcschr( lpszDestination, ' ' );	
		if ( szPos )
		{
			lpszDestination = (szPos + 1);
			szPos = wcschr( lpszDestination, ',' );
			if ( szPos )
			{
				*szPos = '\0';
			}
		}
	}
	//
	// Remove arguments after path
	//
	szPos = wcsrchr( lpszDestination, L'.' );
	szSpace = wcsrchr( lpszDestination, L' ' );
	if ( szSpace > szPos ) 
		*szSpace = '\0';

	//
	// lets see if it starts with an c:\ or something, else we will attach a C:\WINDOWS\ or C:\WINDOWS\SYSTEM32\
	//
	if ( FileExists(lpszDestination) )
		return lpszDestination;

	wchar_t szTemp[ MAX_PATH +1 ];
	UINT nDirLength;

	nDirLength = GetWindowsDirectoryW( szTemp, MAX_PATH );
	wcscat_s( szTemp, MAX_PATH - nDirLength, L"\\" );
	wcscat_s(szTemp, MAX_PATH - nDirLength - 1, lpszDestination );
	if ( FileExists(szTemp) )
	{
		wcsncpy_s( lpszDestinationPath, nDirLength, szTemp, MAX_PATH );
		return lpszDestinationPath;
	}

	nDirLength = GetSystemDirectoryW( szTemp, MAX_PATH );
	wcscat_s( szTemp, MAX_PATH - nDirLength, L"\\" );
	wcscat_s( szTemp, MAX_PATH - nDirLength - 1, lpszDestination );
	if ( FileExists(szTemp) )
	{
		wcsncpy_s( lpszDestinationPath, dwSize, szTemp, MAX_PATH );
		return lpszDestinationPath;
	}

	return NULL;

}

struct RegistryScanInfo
{
	HKEY hKey;
	WCHAR *szPath;
};

BOOL ScanQuick( CPeFile &pFile )
{
	BOOL fResult = FALSE;
	HKEY hReg = NULL;
	DWORD dwDisposion = 0;
	WCHAR szValueName[ MAX_PATH +1 ] = { 0 };
	DWORD dwIndex = 0;
	DWORD dwValueNameSize = 0;
	DWORD dwType = 0;
	BYTE lpData[ 0x800 ] = { 0 };
	WCHAR szDestinationFilePath[ MAX_PATH + 1 ] = { 0 };
	WCHAR *lpszScanPath = NULL;
	DWORD dwFilePathSize = 0;
	DWORD dwDataSize = 0;
	DWORD dwResult = 0;

	RegistryScanInfo RegistryKeys[ 10 ] = {
		{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run" },
		{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce" },
		{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices" },
		{ HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run" },
		{ HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce" },
		{ HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\RunServices" },
		{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit" },
		{ HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell" },
		{ HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Known DLLs" },
		{ HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SharedTaskScheduler" }
	};

	printf( "* Registry Quick Scan\n" );

	dwDisposion = REG_OPENED_EXISTING_KEY;
	for ( int n = 0; n < sizeof(RegistryKeys) / sizeof(RegistryKeys[0]); n++ )
	{
		if ( RegCreateKeyExW( RegistryKeys[n].hKey, RegistryKeys[n].szPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, NULL, &hReg, &dwDisposion ) == ERROR_SUCCESS )
		{
			dwIndex = 0;
			while ( TRUE )
			{
				dwDataSize = sizeof(lpData);
				dwValueNameSize = MAX_PATH;
				dwType = REG_SZ;
				dwResult = RegEnumValueW( hReg, dwIndex, szValueName, &dwValueNameSize, NULL, &dwType, lpData, &dwDataSize );
				if ( dwResult == ERROR_SUCCESS )
				{
					if ( lpData && *lpData )
					{
						dwFilePathSize = MAX_PATH;
						lpszScanPath = ExtractFileName( (LPCWSTR)lpData, dwFilePathSize, szDestinationFilePath );
						if ( lpszScanPath )
						{
							ScanFile( pFile, (LPWSTR)lpszScanPath, FALSE );
						}
					}
					dwIndex++;
				}
				else 
				{
					//
					// some error occurred or we have scanned all items
					//
					if ( dwResult != ERROR_NO_MORE_ITEMS )
					{
						continue;
					}
					break;
				}
			}
			RegCloseKey( hReg );
		}
	}

	//hRegistry = RegCreateKeyExW( HKEY_LOCAL_MACHINE, 

	return fResult;
}

int wmain(int argc, wchar_t * argv[] )
{
	CPeFile *pFile = NULL;
	BOOL fDirectory = FALSE;
	BOOL fInvalidParameter = FALSE;
	BOOL fQuickScan = FALSE;
	LPWSTR szScanPath = NULL;
	BOOL fVerbose = FALSE;

	printf( "Malware Resource Scanner v0.1 by Esmid Idrizovic\n" );
	printf( "27. October 2011\n\n" );

	if ( argc < 2 )
	{
		ShowInfo();
		return 0;
	}
	else
	{
		pFile = new CPeFile();
		pFile->SetCallback( (ResourceCallbackFunction*)&MyResourcesCallback );

		for ( int n = 1; n < argc; n++ )
		{
			if ( _wcsicmp(argv[n], L"-unpack") == 0 )
			{
				pFile->SetUnpackFlag( TRUE );
			}
			else if ( _wcsicmp(argv[n], L"-d") == 0 )
			{
				if ( (n + 1) < argc )
				{
					fDirectory = TRUE;
				}
				else
				{
					fInvalidParameter = TRUE;
					break;
				}
			}
			else if ( _wcsicmp(argv[n], L"-v") == 0 )
			{
				fVerbose = TRUE;
			}
			else if ( _wcsicmp(argv[n], L"-quickscan") == 0 )
			{
				fQuickScan = TRUE;
			}
			else
			{
				if ( argv[n] ) szScanPath = argv[n];
			}
		}
	}

	if ( fInvalidParameter || (!fQuickScan && !szScanPath) )
	{
		ShowInfo();
	}
	else if ( fQuickScan )
	{
		ScanQuick( *pFile );
	}
	else if ( szScanPath)
	{
		if ( fDirectory )
		{
			ScanDirectory( *pFile, szScanPath, fVerbose );
		}
		else
		{
			ScanFile( *pFile, szScanPath, fVerbose );
		}
	}

	delete pFile;

	return 0;
}