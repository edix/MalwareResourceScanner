#pragma once
#include "windows.h"

#define RM_ENUM_TYPE		0
#define RM_ENUM_NAME		1
#define RM_ENUM_LANG		2
#define RM_XRAY				3
#define RM_ENUM_RESOURCE	4

struct ResourceDirectoryTable
{
	DWORD	dwCharacteristics;
	DWORD	dwTimeDateStamp;
	WORD	dwMajorVersion;
	WORD	dwMinorVersion;
	WORD	dwNumberOfNameEntries;
	WORD	dwNumberOfIDEntries;
};

struct ResourceDirectoryEntry
{
	union
	{
		DWORD	dwNameRva;			// address of the string that gives the Type, Name or Language ID entry (table level dependent)
		INT32	nIntegerID;			// the integer that identifies the Type, Name or Language ID entry
	};
	union
	{
		DWORD	dwDataRva;			// high bit = 0, address of the resource data within the resource section(leaf)
		DWORD	dwSubDirectoryRva;	// high bit = 1, the lower 31 bits are the address of another resource directory table (one level down)
	};
};

struct ResourceDataEntry
{
	DWORD	dwDataRva;
	DWORD	dwSize;
	DWORD	dwCodePage;
	DWORD	dwReserved;
};

struct XRayInformation
{
	ResourceDataEntry		*lpDataEntry;
	ResourceDirectoryEntry	*lpType;
	ResourceDirectoryEntry	*lpName;
	ResourceDirectoryEntry	*lpLanguage;
	DWORD64					dwFileOffset;
	UINT64					ui64EncryptionKey;
};

#define LODWORD(l)           ((DWORD)(l & 0x00000000ffffffff))
#define HIDWORD(l)           ((DWORD)(( l >> 32) & 0x00000000ffffffff))

typedef DWORD (WINAPI * ResourceCallbackFunction) ( LPVOID lpObject, DWORD dwMessage, LPVOID lpEntry, LPVOID lpParam1 );

class CResourceParser
{
	BYTE* m_pBuffer;
	DWORD m_dwFileSize;

	WCHAR m_szFileName[ MAX_PATH + 1 ];

	PIMAGE_DOS_HEADER m_DosHeader;
	PIMAGE_NT_HEADERS32 m_NtHeader;
	BOOL m_fPePlus;
	BOOL m_fUnpack;
	DWORD m_dwDumpIndex;

	ResourceCallbackFunction *m_lpCallback;

private:
	BOOL ReadHeaders();
	BOOL SearchEncryptionKey( BYTE* pBuffer, DWORD dwSize, UINT64 unSearchMask, UINT64& unKey, UINT8 unKeySize );
	BOOL IsBufferValidPE( const BYTE* pBuffer, DWORD dwSize );
	BOOL FindEntry( ResourceDirectoryTable* lpResRoot, ResourceDirectoryEntry* pEntry, LPWSTR lpSearch );

public:
	CResourceParser()
	{
		m_pBuffer = NULL;
		m_lpCallback = NULL;
		m_fUnpack = FALSE;
		memset( m_szFileName, 0, sizeof(m_szFileName) );
		m_dwDumpIndex = 0;
	}
	~CResourceParser() { delete[] m_pBuffer; };
	BOOL LoadFile( LPCWSTR szFileName );
	DWORD64 RvaToFileOffset( DWORD64 dwRVA );
	DWORD64 RvaToFileOffset( DWORD64 dwRVA, const BYTE* pBuffer, WORD wNumberOfSections );
	BOOL ParseResources( );
	BOOL FindResource( LPWSTR lpType, LPWSTR lpName, WORD nLanguage, DWORD64& wOffset, DWORD& dwSize );
	BOOL XRayBuffer( BYTE* pBuffer, DWORD dwSize, UINT64& unKey );

	//
	// class
	//
	void SetCallback( ResourceCallbackFunction* lpCallback ) { m_lpCallback = lpCallback; };
	BYTE* GetBuffer() { return m_pBuffer; };
	DWORD GetSize() { return m_dwFileSize; };
	void SetUnpackFlag( BOOL fUnpack ) { m_fUnpack = fUnpack; };
	BOOL GetUnpackFlag() const { return m_fUnpack; };
	WCHAR* GetFileName() { return m_szFileName; };
	DWORD GetDumpIndex() const { return m_dwDumpIndex; };
	void IncDumpIndex() { m_dwDumpIndex++; };
};

