#pragma once
#include "windows.h"

enum ResourceCallbackNames{ RM_ENUM_TYPE = 0, RM_ENUM_NAME,  RM_ENUM_LANG, RM_XRAY, RM_ENUM_RESOURCE};

struct ResourceDirectoryTable
{
	DWORD	dwCharacteristics;
	DWORD	dwTimeDateStamp;
	WORD	dwMajorVersion;
	WORD	dwMinorVersion;
	WORD	dwNumberOfNameEntries;
	WORD	dwNumberOfIDEntries;
};

struct ResourceDirectoryEntry
{
	union
	{
		DWORD	dwNameRva;			// address of the string that gives the Type, Name or Language ID entry (table level dependent)
		INT32	nIntegerID;			// the integer that identifies the Type, Name or Language ID entry
	};
	union
	{
		DWORD	dwDataRva;			// high bit = 0, address of the resource data within the resource section(leaf)
		DWORD	dwSubDirectoryRva;	// high bit = 1, the lower 31 bits are the address of another resource directory table (one level down)
	};
};

struct ResourceDataEntry
{
	DWORD	dwDataRva;
	DWORD	dwSize;
	DWORD	dwCodePage;
	DWORD	dwReserved;
};

struct XRayInformation
{
	ResourceDataEntry		*lpDataEntry;
	ResourceDirectoryEntry	*lpType;
	ResourceDirectoryEntry	*lpName;
	ResourceDirectoryEntry	*lpLanguage;
	DWORD64					dwFileOffset;
	UINT64					ui64EncryptionKey;
};

#define LODWORD(l)           ((DWORD)(l & 0x00000000ffffffff))
#define HIDWORD(l)           ((DWORD)(( l >> 32) & 0x00000000ffffffff))

typedef DWORD (WINAPI * ResourceCallbackFunction) ( LPVOID lpObject, DWORD dwMessage, LPVOID lpEntry, LPVOID lpParam1 );


struct SearchInfo
{
	UINT64 ui64SearchMask;
	UINT8 unKeySize;
};

const SearchInfo g_SearchInfoArray[] = 
{ 
	{0x00505a4d, 4},	// Delphi
	{0x00905a4d, 4},	// C / Assembler
	{0x00005a4d, 4},
	{0x0000000200505a4d, 8},
	{0x0000000300505a4d, 8},
	{0x0000000000505a4d, 8}
};


class CResourceParser
{
	BYTE* m_pBuffer;
	DWORD m_dwFileSize;

	WCHAR m_szFileName[ MAX_PATH + 1 ];

	PIMAGE_DOS_HEADER m_DosHeader;
	PIMAGE_NT_HEADERS32 m_NtHeader;
	PIMAGE_NT_HEADERS64 m_NtHeader64;
	BOOL m_fPePlus;
	BOOL m_fDumpFile;
	DWORD m_dwDumpNumber;

	ResourceCallbackFunction *m_lpCallback;

private:
	BOOL ReadHeaders();
	BOOL SearchEncryptionKey( BYTE* pBuffer, DWORD dwSize, UINT64 unSearchMask, UINT64& unKey, UINT8 unKeySize );
	BOOL IsValidPEInBuffer( const BYTE* pBuffer, DWORD dwSize );
	//BOOL FindEntry( ResourceDirectoryTable* lpResRoot, ResourceDirectoryEntry* pEntry, LPWSTR lpSearch );

public:
	CResourceParser()
	{
		m_pBuffer = NULL;
		m_lpCallback = NULL;
		m_fDumpFile = FALSE;
		memset( m_szFileName, 0, sizeof(m_szFileName) );
		m_dwDumpNumber = 0;
		m_DosHeader = NULL;
		m_NtHeader = NULL;
		m_NtHeader64 = NULL;
		m_dwFileSize = 0;
		m_fPePlus = FALSE;
	}
	~CResourceParser() { delete[] m_pBuffer; };
	BOOL LoadFile( LPCWSTR szFileName );
	DWORD64 RvaToFileOffset( DWORD64 dwRVA );
	DWORD64 RvaToFileOffset( DWORD64 dwRVA, const BYTE* pBuffer, WORD wNumberOfSections, BOOL fPePlus );
	BOOL ParseResources( );
	//BOOL FindResource( LPWSTR lpType, LPWSTR lpName, WORD nLanguage, DWORD64& wOffset, DWORD& dwSize );
	BOOL XRayBuffer( BYTE* pBuffer, DWORD dwSize, UINT64& unKey );

	//
	// class
	//
	void SetCallback( ResourceCallbackFunction* lpCallback ) { m_lpCallback = lpCallback; };
	BYTE* GetBuffer() { return m_pBuffer; };
	DWORD GetSize() { return m_dwFileSize; };
	void SetDumpFlag( BOOL fDumpFile ) { m_fDumpFile = fDumpFile; };
	BOOL GetDumpFlag() const { return m_fDumpFile; };
	WCHAR* GetFileName() { return m_szFileName; };
	DWORD GetDumpNumber() const { return m_dwDumpNumber; };
	void IncrementDumpNumber() { m_dwDumpNumber++; };
};

