#include "ResourceParser.h"

BOOL CResourceParser::LoadFile( LPCWSTR szFileName )
{
	DWORD dwNumberOfBytesRead;
	HANDLE hFile;
	BOOL fResult;

	if (!szFileName)
		return FALSE;

	//
	// remove old buffer
	//
	if (m_pBuffer)
	{
		delete[] m_pBuffer;
		m_pBuffer = NULL;
	}

	fResult = FALSE;

	//
	// open file for read
	//
	hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if ( hFile != INVALID_HANDLE_VALUE )
	{
		m_dwFileSize = GetFileSize(hFile, NULL);
		if ( m_dwFileSize != INVALID_FILE_SIZE )
		{
			//
			// allocate new buffer and read the file into our buffer
			//
			m_pBuffer = new BYTE[ m_dwFileSize ];
			SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
			if ( !ReadFile(hFile, m_pBuffer, m_dwFileSize, &dwNumberOfBytesRead, NULL) || m_dwFileSize != dwNumberOfBytesRead )
			{
				//
				// something failed, remove the buffer and set it to NULL
				//
				delete[] m_pBuffer;
				m_pBuffer = NULL;
			}
			else
			{
				//
				// file got successful read into the buffer
				// now check if its a valid PE and then read it into the buffer
				//
				wcscpy_s( m_szFileName, MAX_PATH, szFileName );
				if ( IsValidPEInBuffer(m_pBuffer, m_dwFileSize) )
				{
					fResult = ReadHeaders();
				}
			}
		}
		CloseHandle( hFile );
	}
	return fResult;
}

BOOL CResourceParser::ReadHeaders()
{
	m_DosHeader = (PIMAGE_DOS_HEADER)m_pBuffer;
	if ( m_DosHeader && m_DosHeader->e_magic == IMAGE_DOS_SIGNATURE )
	{
		m_NtHeader = (PIMAGE_NT_HEADERS32)( (char*)m_pBuffer + m_DosHeader->e_lfanew );
		m_NtHeader64 = (PIMAGE_NT_HEADERS64)m_NtHeader;
		if ( m_NtHeader && m_NtHeader->Signature == IMAGE_NT_SIGNATURE )
		{
			m_fPePlus = m_NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CResourceParser::IsValidPEInBuffer( const BYTE* pBuffer, DWORD dwSize )
{
	PIMAGE_DOS_HEADER DosHeader;
	PIMAGE_NT_HEADERS32 NtHeader;
	PIMAGE_NT_HEADERS64 NtHeader64;
	DWORD64 dwTemp;

	if ( pBuffer == NULL || dwSize == 0 )
		return FALSE;

	if ( dwSize < (sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS32) + sizeof(IMAGE_SECTION_HEADER)) )		// test if there are enough bytes for the check
		return FALSE;

	__try
	{
		DosHeader = (PIMAGE_DOS_HEADER)pBuffer;
		if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE )
		{
			if ( (DWORD)DosHeader->e_lfanew >= dwSize )
				return FALSE;

			NtHeader = (PIMAGE_NT_HEADERS) ( (char*)pBuffer + DosHeader->e_lfanew );
			NtHeader64 = (PIMAGE_NT_HEADERS64)(NtHeader);
			if ( NtHeader->Signature == IMAGE_NT_SIGNATURE )
			{
				BOOL fPePlus = NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;

				if ( fPePlus )
				{
					//
					// 64 bit PE file
					//
					dwTemp = RvaToFileOffset( NtHeader64->OptionalHeader.AddressOfEntryPoint, pBuffer, NtHeader64->FileHeader.NumberOfSections, TRUE );
					if ( dwTemp == (DWORD64)-1 )
						return FALSE;

					dwTemp = RvaToFileOffset( NtHeader64->OptionalHeader.BaseOfCode, pBuffer, NtHeader64->FileHeader.NumberOfSections, TRUE );
					if ( dwTemp == (DWORD64)-1 )
						return FALSE;
				}
				else
				{
					//
					// 32 bit PE file
					//
					dwTemp = RvaToFileOffset( NtHeader->OptionalHeader.AddressOfEntryPoint, pBuffer, NtHeader->FileHeader.NumberOfSections, FALSE );
					if ( dwTemp == (DWORD64)-1 )
						return FALSE;

					dwTemp = RvaToFileOffset( NtHeader->OptionalHeader.BaseOfCode, pBuffer, NtHeader->FileHeader.NumberOfSections, FALSE );
					if ( dwTemp == (DWORD64)-1 )
						return FALSE;
				}

				return TRUE;
			}
		}
	} __except( 1 )
	{
		//
		// exception
		//
	}
	return FALSE;
}

DWORD64 CResourceParser::RvaToFileOffset( DWORD64 dwRVA )
{
	if ( m_fPePlus )
		return RvaToFileOffset(dwRVA, m_pBuffer, m_NtHeader64->FileHeader.NumberOfSections, TRUE ); // 64bit PE
	return RvaToFileOffset( dwRVA, m_pBuffer, m_NtHeader->FileHeader.NumberOfSections, FALSE );	// 32bit
}

DWORD64 CResourceParser::RvaToFileOffset( DWORD64 dwRVA, const BYTE* pBuffer, WORD wNumberOfSections, BOOL fPePlus )
{
	DWORD64 dwFileOffset;
	PIMAGE_SECTION_HEADER pSection;

	dwFileOffset = (DWORD64)-1;

	if ( pBuffer == NULL || wNumberOfSections == 0 )
		return dwFileOffset;

	pSection = (PIMAGE_SECTION_HEADER)( (char*)pBuffer + ((IMAGE_DOS_HEADER*)(pBuffer))->e_lfanew + (fPePlus ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32)) );

	for ( WORD n = 0; n < wNumberOfSections; n++, pSection++ )
	{
		if ( pSection && dwRVA >= pSection->VirtualAddress && dwRVA < (pSection->VirtualAddress + pSection->Misc.VirtualSize) )
		{
			dwFileOffset = dwRVA - pSection->VirtualAddress + pSection->PointerToRawData;
			break;
		}
	}
	
	return dwFileOffset;
}

BOOL CResourceParser::ParseResources()
{
	DWORD64 dwResourceFileOffset = 0, dwDataFileOffset = 0, dwResourceVA = 0, dwResourceSize = 0;

	ResourceDirectoryTable *lpResRoot, *lpResType, *lpResName;
	ResourceDirectoryEntry *lpEntry1, *lpEntry2, *lpEntry3;
	ResourceDataEntry *pData;
	BOOL fFound = FALSE;
	XRayInformation XRayInfo;

	UINT64 ui64Key = 0;

	if ( m_pBuffer == NULL || m_NtHeader == NULL || (m_fPePlus && !m_NtHeader64) )
		return FALSE;

	//
	// check if we have a valid PE file with a resource section
	//

	if ( m_fPePlus )
	{
		dwResourceVA = m_NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
		dwResourceSize = m_NtHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
	}
	else
	{
		dwResourceVA = m_NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
		dwResourceSize = m_NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
	}

	if ( dwResourceSize == 0 || dwResourceVA == 0 )
		return FALSE;

	//
	// get resource section
	//
	dwResourceFileOffset = RvaToFileOffset( dwResourceVA );

	if ( dwResourceFileOffset == (DWORD64)-1 )
		return FALSE;
		
	lpResRoot = reinterpret_cast<ResourceDirectoryTable*>( m_pBuffer + dwResourceFileOffset );
	if ( lpResRoot->dwCharacteristics != 0 )
		return FALSE;

	// 
	// enumerate all types
	// 
	for ( WORD i = 0; i < lpResRoot->dwNumberOfIDEntries + lpResRoot->dwNumberOfNameEntries; i++)
	{
		lpEntry1 = reinterpret_cast<ResourceDirectoryEntry *>(lpResRoot + 1) + i;
		if ( (lpEntry1->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
			return FALSE;

		lpResType = reinterpret_cast<ResourceDirectoryTable*>(reinterpret_cast<char*>(lpResRoot) + (lpEntry1->dwDataRva & 0x7FFFFFFF));

		//
		// call callback function
		//
		if ( m_lpCallback ) ((ResourceCallbackFunction)m_lpCallback)( static_cast<LPVOID>(this), RM_ENUM_TYPE, (LPVOID)lpEntry1, NULL );

		//
		// enumerate all names
		//
		for ( WORD j = 0; j < lpResType->dwNumberOfIDEntries + lpResType->dwNumberOfNameEntries; j++ )
		{
			lpEntry2 = reinterpret_cast<ResourceDirectoryEntry*>(lpResType + 1) + j;
			if ( (lpEntry2->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
				return FALSE;

			lpResName = reinterpret_cast<ResourceDirectoryTable *>(reinterpret_cast<char*>(lpResRoot) + (lpEntry2->dwDataRva & 0x7FFFFFFF));

			//
			// call callback function
			//
			if ( m_lpCallback ) ((ResourceCallbackFunction)m_lpCallback)( static_cast<LPVOID>(this), RM_ENUM_NAME, (LPVOID)lpEntry2, NULL );

			//
			// enumerate all languages 
			// now we have access to the offsets of the data
			//
			for ( WORD k = 0; k < lpResName->dwNumberOfIDEntries + lpResName->dwNumberOfNameEntries; k++ )
			{
				lpEntry3 = reinterpret_cast<ResourceDirectoryEntry *>(lpResName +1) + k;
				if ( (lpEntry3->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
					return FALSE;

				pData = reinterpret_cast<ResourceDataEntry *>(reinterpret_cast<char*>(lpResRoot) + (lpEntry3->dwDataRva & 0x7FFFFFFF));

				dwDataFileOffset = RvaToFileOffset( pData->dwDataRva );
				if ( dwDataFileOffset == (DWORD64)-1 )
					continue;	// encrypted resource?

				//
				// call callback function
				//
				if ( m_lpCallback ) ((ResourceCallbackFunction)m_lpCallback)( static_cast<LPVOID>(this), RM_ENUM_LANG, (LPVOID)lpEntry3, &dwDataFileOffset );

				//
				// check if data is encrypted (invalid offset) and if file size is larger than 0 bytes
				//
				if ( dwDataFileOffset && dwDataFileOffset < m_dwFileSize && pData->dwSize > 0 )
				{
					//
					// try X Ray on that buffer
					//
					ui64Key = 0;

					if ( XRayBuffer(static_cast<BYTE*>(m_pBuffer + dwDataFileOffset), pData->dwSize, ui64Key) )
					{
						//
						// call callback function
						//
						memset( &XRayInfo, 0, sizeof(XRayInformation) );
							
						XRayInfo.lpType = lpEntry1;
						XRayInfo.lpName = lpEntry2;
						XRayInfo.lpLanguage = lpEntry3;
						XRayInfo.lpDataEntry = pData;
						XRayInfo.dwFileOffset = dwDataFileOffset;
						XRayInfo.ui64EncryptionKey = ui64Key; 

						if ( m_lpCallback ) ((ResourceCallbackFunction)m_lpCallback)( static_cast<LPVOID>(this), RM_XRAY, (LPVOID)lpEntry3, &XRayInfo );

						fFound = TRUE;
					}
				}
			}
		}
	}
	return fFound ? TRUE : FALSE;
}

BOOL CResourceParser::SearchEncryptionKey( BYTE* pBuffer, DWORD dwSize, UINT64 ui64SearchMask, UINT64 &ui64Key, UINT8 unKeySize )
{
	UINT64 ui64DecryptKey = 0;
	DWORD dwRevertBytes = 0;
	BOOL fResult = FALSE;

	ui64Key = 0;

	//
	// get decryption key
	//
	if (unKeySize == 4)
	{
		ui64DecryptKey = *(DWORD*)(pBuffer) ^ (DWORD)ui64SearchMask;
	}
	else if (unKeySize == 8)
	{
		ui64DecryptKey = *(UINT64*)(pBuffer) ^ (UINT64)ui64SearchMask;
	}

	//
	// decrypt the whole buffer
	// 
	__try
	{
		for ( DWORD n = 0; n < dwSize; n += unKeySize )
		{
			if (unKeySize == 4)
			{
				*(DWORD*)(pBuffer + n) ^= (DWORD)ui64DecryptKey; 
			}
			else if ( unKeySize == 8)
			{
				*(UINT64*)(pBuffer + n) ^= (UINT64)ui64DecryptKey;
			}
			dwRevertBytes += unKeySize;
		}
	}
	__except( 1 )
	{
		// error while writing in buffer
	}

	//
	// check if its a valid PE file ( DOS + NT Headers + offset calculation from EP )
	//
	if ( IsValidPEInBuffer(pBuffer, dwRevertBytes) )
	{
		ui64Key = ui64DecryptKey;
		fResult = TRUE;
	}
	else
	{
		//
		// revert
		//
		for ( DWORD n = 0; n < dwRevertBytes; n += unKeySize )
		{
			switch ( unKeySize )
			{
			case 4:
				*(DWORD*)(pBuffer + n) ^= (DWORD)ui64DecryptKey; 
				break;
			case 8:
				*(UINT64*)(pBuffer + n) ^= (UINT64)ui64DecryptKey;
				break;
			default:
				break;
			}
		}
	}
	return fResult;
}

BOOL CResourceParser::XRayBuffer( BYTE* pBuffer, DWORD dwSize, UINT64& ui64Key )
{
	if ( pBuffer == NULL || dwSize == 0 )
		return FALSE;

	//
	// check if its a valid PE file 
	//
	if ( IsValidPEInBuffer(pBuffer, dwSize) )
		return TRUE;	

	//
	// Encrypt buffer
	//
	for ( unsigned int n = 0; n < sizeof(g_SearchInfoArray) / sizeof(g_SearchInfoArray[0]); n++ )
	{
		if ( SearchEncryptionKey(pBuffer, dwSize, g_SearchInfoArray[n].ui64SearchMask, ui64Key, g_SearchInfoArray[n].unKeySize) )
			return TRUE;
	}

	return FALSE;
}


////
//// search for entries
//// lpResRoot = Root Resource Directory
//// lpEntry = Current Entry
//// lpSearch = Search Name or ID
////
//BOOL CResourceParser::FindEntry( ResourceDirectoryTable *lpResRoot, ResourceDirectoryEntry *lpEntry, LPWSTR lpSearch )
//{
//	WCHAR *lpName; 
//	WORD nLength;
//	BOOL fResult = FALSE;
//
//	//
//	// search by ID
//	//
//	if ( IS_INTRESOURCE( lpSearch ) )
//	{
//		if ( IS_INTRESOURCE( lpEntry->nIntegerID  ) )
//		{
//			if ( (INT32)lpSearch == lpEntry->nIntegerID )
//			{
//				fResult = TRUE;
//			}
//		}
//	}
//	else
//	{
//		//
//		// search by Name
//		//
//		if ( !IS_INTRESOURCE( lpEntry->nIntegerID ) )
//		{
//			nLength = *(WORD*)((const char*)lpResRoot + (lpEntry->dwNameRva & 0x7FFFFFFF));
//			lpName = (WCHAR*)((const char*)lpResRoot + (lpEntry->dwNameRva & 0x7FFFFFFF) + sizeof(WORD));
//
//			if ( _wcsnicmp( lpName, lpSearch, nLength ) == 0 )
//			{
//				fResult = TRUE;
//			}
//		}
//	}
//	return fResult;
//}
//
//
///*
//	lpType = Type of resource
//	lpName = Name of resource
//	nLanguage = Language ID, use -1 if you want to have the first language entry. 
//*/
//BOOL CResourceParser::FindResource( LPWSTR lpType, LPWSTR lpName, WORD wLanguage, DWORD64& dwOffset, DWORD& dwSize )
//{
//	DWORD64 dwResourceFileOffset = 0, dwResourceVA = 0, dwResourceSize = 0;
//
//	ResourceDirectoryTable *lpResRoot, *lpResType, *lpResName;
//	ResourceDirectoryEntry *lpEntry1, *lpEntry2, *lpEntry3;
//	ResourceDataEntry *pData;
//	
//	BOOL fFoundDirectory = FALSE;
//
//	if ( !m_pBuffer || !m_NtHeader )
//		return FALSE;
//
//	//
//	// check if we have a valid PE file with a resource section
//	//
//	dwResourceVA = m_NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
//	dwResourceSize = m_NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
//
//	if ( dwResourceSize == 0 || dwResourceVA == 0 )
//		return FALSE;
//
//	//
//	// get resource section
//	//
//	dwResourceFileOffset = RvaToFileOffset( dwResourceVA );
//	if ( dwResourceFileOffset == (DWORD64)-1 )
//		return FALSE;
//		
//	lpResRoot = (ResourceDirectoryTable *)( m_pBuffer + dwResourceFileOffset );
//	if ( lpResRoot->dwCharacteristics != 0 )
//		return FALSE;
//
//	// 
//	// enumerate all types
//	// 
//	for ( WORD i = 0; i < lpResRoot->dwNumberOfIDEntries + lpResRoot->dwNumberOfNameEntries; i++)
//	{
//		lpEntry1 = (ResourceDirectoryEntry *) (lpResRoot + 1) + i;
//		if ( (lpEntry1->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
//			return FALSE;
//
//		lpResType = (ResourceDirectoryTable *) ((const char*)lpResRoot + (lpEntry1->dwDataRva & 0x7FFFFFFF));
//		if ( !lpResType )
//			return FALSE;
//
//		if ( !FindEntry( lpResRoot, lpEntry1, lpType ) ) 
//			continue;
//
//		//
//		// enumerate all names
//		//
//		for ( WORD j = 0; j < lpResType->dwNumberOfIDEntries + lpResType->dwNumberOfNameEntries; j++ )
//		{
//			lpEntry2 = (ResourceDirectoryEntry *) (lpResType + 1) + j;
//			if ( !lpEntry2 || (lpEntry2->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
//				return FALSE;
//
//			lpResName = (ResourceDirectoryTable *) ((const char*)lpResRoot + (lpEntry2->dwDataRva & 0x7FFFFFFF));
//			if ( !lpResName )
//				return FALSE;
//
//			if ( !FindEntry( lpResRoot, lpEntry2, lpName ) ) 
//				continue;
//
//			//
//			// enumerate all languages 
//			// now we have access to the offsets of the data
//			//
//			for ( WORD k = 0; k < lpResName->dwNumberOfIDEntries + lpResName->dwNumberOfNameEntries; k++ )
//			{
//				lpEntry3 = (ResourceDirectoryEntry *) (lpResName +1) + k;
//				if ( (lpEntry3->dwDataRva & 0x7FFFFFFF) >= dwResourceSize )
//					return FALSE;
//
//				if ( wLanguage != (WORD)-1 )
//				{
//					if ( !FindEntry( lpResRoot, lpEntry3, (LPWSTR)wLanguage ) ) 
//						continue;
//				}
//
//				pData = (ResourceDataEntry *) ((const char*)lpResRoot + (lpEntry3->dwDataRva & 0x7FFFFFFF));
//				dwOffset = RvaToFileOffset( pData->dwDataRva );
//				if ( dwOffset == (DWORD64)-1 || pData->dwSize == 0 )
//					return FALSE;
//				
//				dwSize = pData->dwSize;
//
//				return TRUE;
//			}
//		}
//	}
//	return FALSE;
//}
//
